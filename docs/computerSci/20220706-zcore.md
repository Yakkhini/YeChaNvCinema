# 2022 å¹´å¼€æºæ“ä½œç³»ç»Ÿè®­ç»ƒè¥

åœ¨è¿™ä¸ªè®­ç»ƒè¥ä¸­ï¼Œæˆ‘ä¼šæ·±å…¥å­¦ä¹ æ“ä½œç³»ç»ŸåŸç†ï¼Œ**ä»é›¶å¼€å§‹** ç”¨ **Rust** è¯­è¨€å†™ä¸€ä¸ªåŸºäº **RISC-V** æ¶æ„çš„ **ç±» Unix å†…æ ¸ã€‚**

## ç¯å¢ƒé…ç½®

### è¿œç¨‹ä»“åº“

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ‰€æœ‰è¿œç¨‹ä»“åº“å¯è§æ€§åº”è®¾ç½®ä¸º Public å…¬å¼€çŠ¶æ€ï¼Œå¦åˆ™ GitHub Action ä¸­çš„è‡ªåŠ¨è¯„åˆ†å¯èƒ½æ— æƒå¼€å§‹ï¼Œæˆ–è€…éœ€ä»˜è´¹æ‰èƒ½ä½¿ç”¨ã€‚

### æœ¬åœ°

æˆ‘è®¡åˆ’åœ¨æœ¬åœ°å¼€å‘ï¼Œç›®å‰ä½¿ç”¨çš„æ˜¯ Manjaro ç³»ç»Ÿã€‚æˆ‘å°†æ‰€æœ‰å®éªŒä¼šç”¨åˆ°çš„æ–‡ä»¶å’Œä»“åº“éƒ½å­˜æ”¾åœ¨äº† `/diske/Rust/zCore/` è·¯å¾„ä¸­ã€‚`/diske` æ˜¯æˆ‘æŒ‚è½½çš„ Windows ç³»ç»Ÿçš„ E ç›˜ã€‚

æœ¬æ–‡æ¡£ä¹Ÿä½¿ç”¨è½¯é“¾æ¥è¿›æ¥äº†ã€‚

```bash
> ln -s ~/Documents/YeChaNvCinema/docs/computerSci/20220706-zcore.md /diske/Rust/zCore/diary.md
```

## å­¦ä¹  Rust ç¼–ç¨‹ (July 06 - July 08)

ç”±äºæˆ‘ä¹‹å‰ä½¿ç”¨ Rust å¼€å‘è¿‡ä¸€ä¸ªå®Œæ•´çš„æ¸¸æˆé¡¹ç›®ï¼ˆè§ [Planting Pong](https://github.com/Yakkhini/PongPlanting)ï¼‰ï¼Œæ‰€ä»¥ç³»ç»Ÿåœ°å­¦ä¹ è¿‡ Rust è¯­è¨€ã€‚ä½†æ˜¯æˆ‘ä»ç„¶æƒ³è·Ÿç€è®­ç»ƒè¥å†è¿‡ä¸€ä¸‹ Rustï¼Œå› ä¸ºæˆ‘ä¹‹å‰çš„å¼€å‘æ¯”è¾ƒé¢å‘ä¸šåŠ¡é€»è¾‘ï¼Œè€Œæ“ä½œç³»ç»Ÿçš„ç¼–å†™è‚¯å®šè¿˜éœ€è¦æ›´é«˜çš„è¦æ±‚ï¼Œå¦‚é”™è¯¯å¤„ç†ã€å¤šçº¿ç¨‹å¹¶å‘ä¹‹ç±»çš„é«˜çº§ç”¨æ³•ä¹Ÿå¯èƒ½ä¼šç”¨åˆ°ã€‚

[**Classroom** - *LearningOS / learn_rust_rustlings-Yakkhini*](https://github.com/LearningOS/learn_rust_rustlings-Yakkhini)

é…ç½® GitHub Classroom:

```bash
> make setupclassroom
```

### Rustlings å®‰è£…åŠä½¿ç”¨

è®­ç»ƒè¥çš„ Rust ä¹ é¢˜å®éªŒæ˜¯ç”± `rustlings` å·¥å…·é©±åŠ¨çš„ã€‚è™½ç„¶ AUR ä¸­å¯ä»¥å®‰è£…ï¼Œä½†æ˜¯ä¸ºäº†æ–¹ä¾¿å’Œæ˜“äºç®¡ç†æˆ‘å°†å®ƒå®‰è£…åœ¨äº† `$HOME/.cargo/bin` ä¸­ã€‚

```bash
> curl -L https://raw.githubusercontent.com/rust-lang/rustlings/main/install.sh | bash
```

ä½¿ç”¨ï¼š

```bash
~/.cargo/bin/rustlings watch

```

### é‡ç‚¹é¢˜ç›®æ±‡æ€»

åœ¨å­¦ä¹ è¿‡ç¨‹ä¸­ï¼Œæˆ‘å‘ç°æˆ‘çš„æ‹…å¿ƒæ˜¯æ­£ç¡®çš„ã€‚ç”±äºæˆ‘ä¹‹å‰çš„å¼€å‘æ¯”è¾ƒä¾§é‡äºä¸šåŠ¡é€»è¾‘ï¼Œæ‰€ä»¥å‰ 40 é“é¢˜çš„å†…å®¹å®Œæˆé€Ÿåº¦å¾ˆå¿«ï¼Œå¯¹å…¶ä¸­çš„æ¦‚å¿µä¹Ÿæ¯”è¾ƒç†Ÿæ‚‰ï¼›ä½†æ˜¯åä¸‰åé“é¢˜çš„å®Œæˆæ¯”è¾ƒè‰°éš¾ã€‚å…¶ä¸­ï¼Œä¸»è¦è€—è´¹æ—¶é—´çš„é¢˜ç›®ç±»å‹æœ‰ **é”™è¯¯å¤„ç†ã€æ³›å‹ã€å®ã€è¿­ä»£å™¨ã€æ™ºèƒ½æŒ‡é’ˆã€çº¿ç¨‹ã€‚**æˆ‘åœ¨è¿™é‡Œåˆ—ä¸¾å‡ºä¸€äº›é‡ç‚¹é¢˜ç›®ï¼Œå¹¶é™„å‡ºè§£å†³åŠæ³•ä¸­åº”æ³¨æ„çš„éƒ¨åˆ†ã€‚

<!-- tabs:start -->

#### **Index**

* é”™è¯¯å¤„ç†ï¼šerror6ï¼Œadvanced_errs1
* æ³›å‹ï¼šgenerics2
* å®ï¼šquiz4
* è¿­ä»£å™¨ï¼šiterators4ï¼Œiterators5
* æ™ºèƒ½æŒ‡é’ˆï¼šbox1
* çº¿ç¨‹ï¼šarc1

#### **error6**

```rust
// errors6.rs

// Using catch-all error types like `Box<dyn error::Error>` isn't recommended
// for library code, where callers might want to make decisions based on the
// error content, instead of printing it out or propagating it further. Here,
// we define a custom error type to make it possible for callers to decide
// what to do next when our function returns an error.

// Make these tests pass! Execute `rustlings hint errors6` for hints :)

use std::num::ParseIntError;

// This is a custom error type that we will be using in `parse_pos_nonzero()`.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl ParsePosNonzeroError {
    // TODO: add another error conversion function here.
    fn from_creation(x: CreationError) -> ParsePosNonzeroError {
        match x {
            CreationError::Negative => ParsePosNonzeroError::Creation(CreationError::Negative),
            CreationError::Zero => ParsePosNonzeroError::Creation(CreationError::Zero),
        }
    }
}

fn parse_pos_nonzero(s: &str) -> Result<PositiveNonzeroInteger, ParsePosNonzeroError> {
    // TODO: change this to return an appropriate error instead of panicking
    // when `parse()` returns an error.
    let x = s.parse();

    match x {
        Ok(x) => PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation),
        Err(e) => {Err(ParsePosNonzeroError::ParseInt(e))},
    }
}

// Don't change anything below this line.

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        match value {
            x if x < 0 => Err(CreationError::Negative),
            x if x == 0 => Err(CreationError::Zero),
            x => Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}
```

#### **generics2**

```rust
// This powerful wrapper provides the ability to store a positive integer value.
// Rewrite it using generics so that it supports wrapping ANY type.

// Execute `rustlings hint generics2` for hints!

struct Wrapper<T> {
    value: T,
}

impl<T> Wrapper<T> {
    pub fn new(value: T) -> Self {
        Wrapper { value }
    }
}
```

#### **iterators4**

```rust
// iterators4.rs

pub fn factorial(num: u64) -> u64 {
    // Complete this function to return the factorial of num
    // Do not use:
    // - return
    // Try not to use:
    // - imperative style loops (for, while)
    // - additional variables
    // For an extra challenge, don't use:
    // - recursion
    // Execute `rustlings hint iterators4` for hints.

    (1..num + 1).product()
}
```

#### **iterators5**

```rust
// iterators5.rs
// Let's define a simple model to track Rustlings exercise progress. Progress
// will be modelled using a hash map. The name of the exercise is the key and
// the progress is the value. Two counting functions were created to count the
// number of exercises with a given progress. These counting functions use
// imperative style for loops. Recreate this counting functionality using
// iterators. Only the two iterator methods (count_iterator and
// count_collection_iterator) need to be modified.
// Execute `rustlings hint iterators5` for hints.
//
// Make the code compile and the tests pass.

use std::collections::HashMap;

#[derive(Clone, Copy, PartialEq, Eq)]
enum Progress {
    None,
    Some,
    Complete,
}

...

fn count_iterator(map: &HashMap<String, Progress>, value: Progress) -> usize {
    // map is a hashmap with String keys and Progress values.
    // map = { "variables1": Complete, "from_str": None, ... }

    map.values().filter(|val| **val == value).count()
}

...

fn count_collection_iterator(collection: &[HashMap<String, Progress>], value: Progress) -> usize {
    // collection is a slice of hashmaps.
    // collection = [{ "variables1": Complete, "from_str": None, ... },
    //     { "variables2": Complete, ... }, ... ]

    collection
        .iter()
        .map(|submap| submap.values().filter(|val| **val == value).count())
        .sum()
}

```

#### **box1**

```rust
// box1.rs
//
// At compile time, Rust needs to know how much space a type takes up. This becomes problematic
// for recursive types, where a value can have as part of itself another value of the same type.
// To get around the issue, we can use a `Box` - a smart pointer used to store data on the heap,
// which also allows us to wrap a recursive type.
//
// The recursive type we're implementing in this exercise is the `cons list` - a data structure
// frequently found in functional programming languages. Each item in a cons list contains two
// elements: the value of the current item and the next item. The last item is a value called `Nil`.
//
// Step 1: use a `Box` in the enum definition to make the code compile
// Step 2: create both empty and non-empty cons lists by replacing `unimplemented!()`
//
// Note: the tests should not be changed
//
// Execute `rustlings hint box1` for hints :)

#[derive(PartialEq, Debug)]
pub enum List {
    Cons(i32, Box<List>),
    Nil,
}

fn main() {
    println!("This is an empty cons list: {:?}", create_empty_list());
    println!(
        "This is a non-empty cons list: {:?}",
        create_non_empty_list()
    );
}

pub fn create_empty_list() -> List {
    List::Nil
}

pub fn create_non_empty_list() -> List {
    List::Cons(1, Box::new(List::Nil))
}

```

#### **arc1**

```rust
/ arc1.rs
// In this exercise, we are given a Vec of u32 called "numbers" with values ranging
// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]
// We would like to use this set of numbers within 8 different threads simultaneously.
// Each thread is going to get the sum of every eighth value, with an offset.
// The first thread (offset 0), will sum 0, 8, 16, ...
// The second thread (offset 1), will sum 1, 9, 17, ...
// The third thread (offset 2), will sum 2, 10, 18, ...
// ...
// The eighth thread (offset 7), will sum 7, 15, 23, ...

// Because we are using threads, our values need to be thread-safe.  Therefore,
// we are using Arc.  We need to make a change in each of the two TODOs.

// Make this code compile by filling in a value for `shared_numbers` where the
// first TODO comment is, and create an initial binding for `child_numbers`
// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!
// Execute `rustlings hint arc1` for hints :)

#![forbid(unused_imports)] // Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let shared_numbers = Arc::new(numbers); // TODO
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = Arc::clone(&shared_numbers); // TODO
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();
            println!("Sum of offset {} is {}", offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}

```

#### **quiz4**

```rust
#[macro_export]
macro_rules! my_macro {
    ($val:expr) => {
        "Hello ".to_owned() + $val
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_my_macro_world() {
        assert_eq!(my_macro!("world!"), "Hello world!");
    }

    #[test]
    fn test_my_macro_goodbye() {
        assert_eq!(my_macro!("goodbye!"), "Hello goodbye!");
    }
}

```

#### **advanced_errs1**

```rust
// advanced_errs1.rs

// Remember back in errors6, we had multiple mapping functions so that we
// could translate lower-level errors into our custom error type using
// `map_err()`? What if we could use the `?` operator directly instead?

// Make this code compile! Execute `rustlings hint advanced_errs1` for
// hints :)

use std::num::ParseIntError;
use std::str::FromStr;

// This is a custom error type that we will be using in the `FromStr`
// implementation.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl From<CreationError> for ParsePosNonzeroError {
    fn from(e: CreationError) -> Self {
        // TODO: complete this implementation so that the `?` operator will
        // work for `CreationError`

        ParsePosNonzeroError::Creation(e)
    }
}

// TODO: implement another instance of the `From` trait here so that the
// `?` operator will work in the other place in the `FromStr`
// implementation below.

impl From<ParseIntError> for ParsePosNonzeroError {
    fn from(e: ParseIntError) -> Self {
        ParsePosNonzeroError::ParseInt(e)
    }
}

// Don't change anything below this line.

impl FromStr for PositiveNonzeroInteger {
    type Err = ParsePosNonzeroError;
    fn from_str(s: &str) -> Result<PositiveNonzeroInteger, Self::Err> {
        let x: i64 = s.parse()?;
        Ok(PositiveNonzeroInteger::new(x)?)
    }
}

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        match value {
            x if x < 0 => Err(CreationError::Negative),
            x if x == 0 => Err(CreationError::Zero),
            x => Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

```

<!-- tabs:end -->

### å®Œæˆ

æ¯é“é¢˜çš„å…·ä½“å®Œæˆæƒ…å†µå¯ä»¥åœ¨ GitHub Commit è®°å½•ä¸­æŸ¥åˆ°ã€‚

Quiz2 åŠä¹‹å‰é¢˜ç›®ï¼š[Finish: Before quiz2(include quiz2). Â· LearningOS/learn_rust_rustlings-Yakkhini@e67dea3](https://github.com/LearningOS/learn_rust_rustlings-Yakkhini/commit/e67dea32e9a5b03114d544276c0e4cef82238d52)

Quiz2 ä¹‹åæ‰€æœ‰é¢˜ç›®ï¼š[Finish: All Done. Â· LearningOS/learn_rust_rustlings-Yakkhini@a079df7](https://github.com/LearningOS/learn_rust_rustlings-Yakkhini/commit/a079df7a058b67ee67cd9e385df90995a9a4fe38)

```bash

ğŸ‰ All exercises completed! ğŸ‰

+----------------------------------------------------+
|          You made it to the Fe-nish line!          |
+--------------------------  ------------------------+
                          \\/
     â–’â–’          â–’â–’â–’â–’â–’â–’â–’â–’      â–’â–’â–’â–’â–’â–’â–’â–’          â–’â–’
   â–’â–’â–’â–’  â–’â–’    â–’â–’        â–’â–’  â–’â–’        â–’â–’    â–’â–’  â–’â–’â–’â–’
   â–’â–’â–’â–’  â–’â–’  â–’â–’            â–’â–’            â–’â–’  â–’â–’  â–’â–’â–’â–’
 â–‘â–‘â–’â–’â–’â–’â–‘â–‘â–’â–’  â–’â–’            â–’â–’            â–’â–’  â–’â–’â–‘â–‘â–’â–’â–’â–’
   â–“â–“â–“â–“â–“â–“â–“â–“  â–“â–“      â–“â–“â–ˆâ–ˆ  â–“â–“  â–“â–“â–ˆâ–ˆ      â–“â–“  â–“â–“â–“â–“â–“â–“â–“â–“
     â–’â–’â–’â–’    â–’â–’      â–ˆâ–ˆâ–ˆâ–ˆ  â–’â–’  â–ˆâ–ˆâ–ˆâ–ˆ      â–’â–’â–‘â–‘  â–’â–’â–’â–’
       â–’â–’  â–’â–’â–’â–’â–’â–’        â–’â–’â–’â–’â–’â–’        â–’â–’â–’â–’â–’â–’  â–’â–’
         â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–“â–“â–’â–’â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’
           â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’
             â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’â–’
           â–’â–’  â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’â–’  â–’â–’
         â–’â–’    â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’    â–’â–’
       â–’â–’    â–’â–’    â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’    â–’â–’    â–’â–’
       â–’â–’  â–’â–’    â–’â–’                  â–’â–’    â–’â–’  â–’â–’
           â–’â–’  â–’â–’                      â–’â–’  â–’â–’

We hope you enjoyed learning about the various aspects of Rust!
If you noticed any issues, please don't hesitate to report them to our repo.
You can also contribute your own exercises to help the greater community!

Before reporting an issue or contributing, please read our guidelines:
https://github.com/rust-lang/rustlings/blob/main/CONTRIBUTING.md

```

## å‚è€ƒ

[*Open-Source-OS-Training-Camp-2022 æ–‡æ¡£*](https://learningos.github.io/rust-based-os-comp2022/index.html)

[*SCHEDULING.md*](https://github.com/LearningOS/rust-based-os-comp2022/blob/main/scheduling.md)

[*Rust ç¨‹åºè®¾è®¡è¯­è¨€ - Rust ç¨‹åºè®¾è®¡è¯­è¨€ ç®€ä½“ä¸­æ–‡ç‰ˆ*](https://kaisery.github.io/trpl-zh-cn/title-page.html)

[*std - Rust*](https://doc.rust-lang.org/std/index.html)