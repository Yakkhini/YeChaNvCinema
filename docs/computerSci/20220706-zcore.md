# 2022 年开源操作系统训练营

在这个训练营中，我会深入学习操作系统原理，**从零开始** 用 **Rust** 语言写一个基于 **RISC-V** 架构的 **类 Unix 内核。**

## 环境配置

### 远程仓库

需要注意的是，所有远程仓库可见性应设置为 Public 公开状态，否则 GitHub Action 中的自动评分可能无权开始，或者需付费才能使用。

### 本地

我计划在本地开发，目前使用的是 Manjaro 系统。我将所有实验会用到的文件和仓库都存放在了 `/diske/Rust/zCore/` 路径中。`/diske` 是我挂载的 Windows 系统的 E 盘。

本文档也使用软链接进来了。

```bash
> ln -s ~/Documents/YeChaNvCinema/docs/computerSci/20220706-zcore.md /diske/Rust/zCore/diary.md
```

## 学习 Rust 编程 (July 06 - July 08)

由于我之前使用 Rust 开发过一个完整的游戏项目（见 [Planting Pong](https://github.com/Yakkhini/PongPlanting)），所以系统地学习过 Rust 语言。但是我仍然想跟着训练营再过一下 Rust，因为我之前的开发比较面向业务逻辑，而操作系统的编写肯定还需要更高的要求，如错误处理、多线程并发之类的高级用法也可能会用到。

[**Classroom** - *LearningOS / learn_rust_rustlings-Yakkhini*](https://github.com/LearningOS/learn_rust_rustlings-Yakkhini)

配置 GitHub Classroom:

```bash
> make setupclassroom
```

### Rustlings 安装及使用

训练营的 Rust 习题实验是由 `rustlings` 工具驱动的。虽然 AUR 中可以安装，但是为了方便和易于管理我将它安装在了 `$HOME/.cargo/bin` 中。

```bash
> curl -L https://raw.githubusercontent.com/rust-lang/rustlings/main/install.sh | bash
```

使用：

```bash
~/.cargo/bin/rustlings watch

```

### 重点题目汇总

在学习过程中，我发现我的担心是正确的。由于我之前的开发比较侧重于业务逻辑，所以前 40 道题的内容完成速度很快，对其中的概念也比较熟悉；但是后三十道题的完成比较艰难。其中，主要耗费时间的题目类型有 **错误处理、泛型、宏、迭代器、智能指针、线程。**我在这里列举出一些重点题目，并附出解决办法中应注意的部分。

<!-- tabs:start -->

#### **Index**

* 错误处理：error6，advanced_errs1
* 泛型：generics2
* 宏：quiz4
* 迭代器：iterators4，iterators5
* 智能指针：box1
* 线程：arc1

#### **error6**

```rust
// errors6.rs

// Using catch-all error types like `Box<dyn error::Error>` isn't recommended
// for library code, where callers might want to make decisions based on the
// error content, instead of printing it out or propagating it further. Here,
// we define a custom error type to make it possible for callers to decide
// what to do next when our function returns an error.

// Make these tests pass! Execute `rustlings hint errors6` for hints :)

use std::num::ParseIntError;

// This is a custom error type that we will be using in `parse_pos_nonzero()`.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl ParsePosNonzeroError {
    // TODO: add another error conversion function here.
    fn from_creation(x: CreationError) -> ParsePosNonzeroError {
        match x {
            CreationError::Negative => ParsePosNonzeroError::Creation(CreationError::Negative),
            CreationError::Zero => ParsePosNonzeroError::Creation(CreationError::Zero),
        }
    }
}

fn parse_pos_nonzero(s: &str) -> Result<PositiveNonzeroInteger, ParsePosNonzeroError> {
    // TODO: change this to return an appropriate error instead of panicking
    // when `parse()` returns an error.
    let x = s.parse();

    match x {
        Ok(x) => PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation),
        Err(e) => {Err(ParsePosNonzeroError::ParseInt(e))},
    }
}

// Don't change anything below this line.

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        match value {
            x if x < 0 => Err(CreationError::Negative),
            x if x == 0 => Err(CreationError::Zero),
            x => Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}
```

#### **generics2**

```rust
// This powerful wrapper provides the ability to store a positive integer value.
// Rewrite it using generics so that it supports wrapping ANY type.

// Execute `rustlings hint generics2` for hints!

struct Wrapper<T> {
    value: T,
}

impl<T> Wrapper<T> {
    pub fn new(value: T) -> Self {
        Wrapper { value }
    }
}
```

#### **iterators4**

```rust
// iterators4.rs

pub fn factorial(num: u64) -> u64 {
    // Complete this function to return the factorial of num
    // Do not use:
    // - return
    // Try not to use:
    // - imperative style loops (for, while)
    // - additional variables
    // For an extra challenge, don't use:
    // - recursion
    // Execute `rustlings hint iterators4` for hints.

    (1..num + 1).product()
}
```

#### **iterators5**

```rust
// iterators5.rs
// Let's define a simple model to track Rustlings exercise progress. Progress
// will be modelled using a hash map. The name of the exercise is the key and
// the progress is the value. Two counting functions were created to count the
// number of exercises with a given progress. These counting functions use
// imperative style for loops. Recreate this counting functionality using
// iterators. Only the two iterator methods (count_iterator and
// count_collection_iterator) need to be modified.
// Execute `rustlings hint iterators5` for hints.
//
// Make the code compile and the tests pass.

use std::collections::HashMap;

#[derive(Clone, Copy, PartialEq, Eq)]
enum Progress {
    None,
    Some,
    Complete,
}

...

fn count_iterator(map: &HashMap<String, Progress>, value: Progress) -> usize {
    // map is a hashmap with String keys and Progress values.
    // map = { "variables1": Complete, "from_str": None, ... }

    map.values().filter(|val| **val == value).count()
}

...

fn count_collection_iterator(collection: &[HashMap<String, Progress>], value: Progress) -> usize {
    // collection is a slice of hashmaps.
    // collection = [{ "variables1": Complete, "from_str": None, ... },
    //     { "variables2": Complete, ... }, ... ]

    collection
        .iter()
        .map(|submap| submap.values().filter(|val| **val == value).count())
        .sum()
}

```

#### **box1**

```rust
// box1.rs
//
// At compile time, Rust needs to know how much space a type takes up. This becomes problematic
// for recursive types, where a value can have as part of itself another value of the same type.
// To get around the issue, we can use a `Box` - a smart pointer used to store data on the heap,
// which also allows us to wrap a recursive type.
//
// The recursive type we're implementing in this exercise is the `cons list` - a data structure
// frequently found in functional programming languages. Each item in a cons list contains two
// elements: the value of the current item and the next item. The last item is a value called `Nil`.
//
// Step 1: use a `Box` in the enum definition to make the code compile
// Step 2: create both empty and non-empty cons lists by replacing `unimplemented!()`
//
// Note: the tests should not be changed
//
// Execute `rustlings hint box1` for hints :)

#[derive(PartialEq, Debug)]
pub enum List {
    Cons(i32, Box<List>),
    Nil,
}

fn main() {
    println!("This is an empty cons list: {:?}", create_empty_list());
    println!(
        "This is a non-empty cons list: {:?}",
        create_non_empty_list()
    );
}

pub fn create_empty_list() -> List {
    List::Nil
}

pub fn create_non_empty_list() -> List {
    List::Cons(1, Box::new(List::Nil))
}

```

#### **arc1**

```rust
/ arc1.rs
// In this exercise, we are given a Vec of u32 called "numbers" with values ranging
// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]
// We would like to use this set of numbers within 8 different threads simultaneously.
// Each thread is going to get the sum of every eighth value, with an offset.
// The first thread (offset 0), will sum 0, 8, 16, ...
// The second thread (offset 1), will sum 1, 9, 17, ...
// The third thread (offset 2), will sum 2, 10, 18, ...
// ...
// The eighth thread (offset 7), will sum 7, 15, 23, ...

// Because we are using threads, our values need to be thread-safe.  Therefore,
// we are using Arc.  We need to make a change in each of the two TODOs.

// Make this code compile by filling in a value for `shared_numbers` where the
// first TODO comment is, and create an initial binding for `child_numbers`
// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!
// Execute `rustlings hint arc1` for hints :)

#![forbid(unused_imports)] // Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let shared_numbers = Arc::new(numbers); // TODO
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = Arc::clone(&shared_numbers); // TODO
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();
            println!("Sum of offset {} is {}", offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}

```

#### **quiz4**

```rust
#[macro_export]
macro_rules! my_macro {
    ($val:expr) => {
        "Hello ".to_owned() + $val
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_my_macro_world() {
        assert_eq!(my_macro!("world!"), "Hello world!");
    }

    #[test]
    fn test_my_macro_goodbye() {
        assert_eq!(my_macro!("goodbye!"), "Hello goodbye!");
    }
}

```

#### **advanced_errs1**

```rust
// advanced_errs1.rs

// Remember back in errors6, we had multiple mapping functions so that we
// could translate lower-level errors into our custom error type using
// `map_err()`? What if we could use the `?` operator directly instead?

// Make this code compile! Execute `rustlings hint advanced_errs1` for
// hints :)

use std::num::ParseIntError;
use std::str::FromStr;

// This is a custom error type that we will be using in the `FromStr`
// implementation.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl From<CreationError> for ParsePosNonzeroError {
    fn from(e: CreationError) -> Self {
        // TODO: complete this implementation so that the `?` operator will
        // work for `CreationError`

        ParsePosNonzeroError::Creation(e)
    }
}

// TODO: implement another instance of the `From` trait here so that the
// `?` operator will work in the other place in the `FromStr`
// implementation below.

impl From<ParseIntError> for ParsePosNonzeroError {
    fn from(e: ParseIntError) -> Self {
        ParsePosNonzeroError::ParseInt(e)
    }
}

// Don't change anything below this line.

impl FromStr for PositiveNonzeroInteger {
    type Err = ParsePosNonzeroError;
    fn from_str(s: &str) -> Result<PositiveNonzeroInteger, Self::Err> {
        let x: i64 = s.parse()?;
        Ok(PositiveNonzeroInteger::new(x)?)
    }
}

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        match value {
            x if x < 0 => Err(CreationError::Negative),
            x if x == 0 => Err(CreationError::Zero),
            x => Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

```

<!-- tabs:end -->

### 完成

每道题的具体完成情况可以在 GitHub Commit 记录中查到。

Quiz2 及之前题目：[Finish: Before quiz2(include quiz2). · LearningOS/learn_rust_rustlings-Yakkhini@e67dea3](https://github.com/LearningOS/learn_rust_rustlings-Yakkhini/commit/e67dea32e9a5b03114d544276c0e4cef82238d52)

Quiz2 之后所有题目：[Finish: All Done. · LearningOS/learn_rust_rustlings-Yakkhini@a079df7](https://github.com/LearningOS/learn_rust_rustlings-Yakkhini/commit/a079df7a058b67ee67cd9e385df90995a9a4fe38)

```bash

🎉 All exercises completed! 🎉

+----------------------------------------------------+
|          You made it to the Fe-nish line!          |
+--------------------------  ------------------------+
                          \\/
     ▒▒          ▒▒▒▒▒▒▒▒      ▒▒▒▒▒▒▒▒          ▒▒
   ▒▒▒▒  ▒▒    ▒▒        ▒▒  ▒▒        ▒▒    ▒▒  ▒▒▒▒
   ▒▒▒▒  ▒▒  ▒▒            ▒▒            ▒▒  ▒▒  ▒▒▒▒
 ░░▒▒▒▒░░▒▒  ▒▒            ▒▒            ▒▒  ▒▒░░▒▒▒▒
   ▓▓▓▓▓▓▓▓  ▓▓      ▓▓██  ▓▓  ▓▓██      ▓▓  ▓▓▓▓▓▓▓▓
     ▒▒▒▒    ▒▒      ████  ▒▒  ████      ▒▒░░  ▒▒▒▒
       ▒▒  ▒▒▒▒▒▒        ▒▒▒▒▒▒        ▒▒▒▒▒▒  ▒▒
         ▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒▒▒▓▓▒▒▓▓▒▒▒▒▒▒▒▒
           ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
             ▒▒▒▒▒▒▒▒▒▒██▒▒▒▒▒▒██▒▒▒▒▒▒▒▒▒▒
           ▒▒  ▒▒▒▒▒▒▒▒▒▒██████▒▒▒▒▒▒▒▒▒▒  ▒▒
         ▒▒    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒    ▒▒
       ▒▒    ▒▒    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒    ▒▒    ▒▒
       ▒▒  ▒▒    ▒▒                  ▒▒    ▒▒  ▒▒
           ▒▒  ▒▒                      ▒▒  ▒▒

We hope you enjoyed learning about the various aspects of Rust!
If you noticed any issues, please don't hesitate to report them to our repo.
You can also contribute your own exercises to help the greater community!

Before reporting an issue or contributing, please read our guidelines:
https://github.com/rust-lang/rustlings/blob/main/CONTRIBUTING.md

```

## 第零章：实验环境配置 - lab0-0 (July 08)

在本章中，我们会完成环境配置并成功运行 **rCore-Tutorial**。

[**Classroom** - *LearningOS / lab0-0-setup-env-run-os1-Yakkhini*](https://github.com/LearningOS/lab0-0-setup-env-run-os1-Yakkhini)

### 安装 Qemu

我计划采用本地开发。Qemu 相关软件包在 Arch 的 `extra/` 仓库中可以找到，打包质量有保证。

```bash
> yay -S qemu qemu-system-riscv qemu-user
> qemu-system-riscv64 --version; qemu-riscv64 --version;
```

**Output：**

```
QEMU emulator version 7.0.0
Copyright (c) 2003-2022 Fabrice Bellard and the QEMU Project developers
qemu-riscv64 version 7.0.0
Copyright (c) 2003-2022 Fabrice Bellard and the QEMU Project developers
```

### 试运行 rCore-Tutorial

裸机操作系统 `os1` 不需要处理用户代码，可以直接运行来检查本地环境是否正确配置。

```bash
> cd os1; LOG=DEBUG make run;
```

**Output：**

```
(rustup target list | grep "riscv64gc-unknown-none-elf (installed)") || rustup target add riscv64gc-unknown-none-elf
riscv64gc-unknown-none-elf (installed)
cargo install cargo-binutils --vers ~0.2
    Updating crates.io index
     Ignored package `cargo-binutils v0.2.0` is already installed, use --force to override
rustup component add rust-src
info: component 'rust-src' is up to date
rustup component add llvm-tools-preview
info: component 'llvm-tools-preview' for target 'x86_64-unknown-linux-gnu' is up to date
    Finished release [optimized] target(s) in 0.01s
make: rust-objcopy: No such file or directory
make: *** [Makefile:22: target/riscv64gc-unknown-none-elf/release/os.bin] Error 127
```

可以看到直接运行出现了错误 `make: rust-objcopy: No such file or directory`。根据实验说明，这个命令会安装一些本地可能没有的依赖。我在运行过程中没有收到 `root` 提权申请，根据项目的工具链，我推测是 `Cargo` 安装在 `~/.cargo/bin/` 目录中的可执行文件不在环境变量路径中。

```bash
> ls ~/.cargo/bin
```

**Output:**

```
cargo-nm       cargo-objdump   cargo-readobj  cargo-strip  rust-ld    rust-lld  rust-objcopy  rust-profdata  rust-size
cargo-objcopy  cargo-profdata  cargo-size     rust-ar      rustlings  rust-nm   rust-objdump  rust-readobj   rust-strip
```

果然，`rust-objcopy` 就在其中。肯定是程序直接使用命令 `rust-objcopy` 调用它失败了，现在的正确命令应该是 `~/.cargo/bin/rust-objcopy`。但是我不想把这个路径纳入环境变量（怕和 Pacman 打架），也不能修改 Makefile，因为有可能会影响评分程序执行。所以还是每次调用前先临时改一下 `PATH` 变量好了。

```bash
export PATH="${PATH}:${HOME}/.cargo/bin"
LOG=DEBUG make run
```

**Output:**

```
(rustup target list | grep "riscv64gc-unknown-none-elf (installed)") || rustup target add riscv64gc-unknown-none-elf
riscv64gc-unknown-none-elf (installed)
cargo install cargo-binutils --vers ~0.2
    Updating crates.io index
     Ignored package `cargo-binutils v0.2.0` is already installed, use --force to override
rustup component add rust-src
info: component 'rust-src' is up to date
rustup component add llvm-tools-preview
info: component 'llvm-tools-preview' for target 'x86_64-unknown-linux-gnu' is up to date
    Finished release [optimized] target(s) in 0.01s
[rustsbi] RustSBI version 0.2.2, adapting to RISC-V SBI v1.0.0
.______       __    __      _______.___________.  _______..______   __
|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |
|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |
|      /     |  |  |  |    \   \       |  |      \   \    |   _  < |  |
|  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |
| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|
[rustsbi] Implementation     : RustSBI-QEMU Version 0.1.1
[rustsbi] Platform Name      : riscv-virtio,qemu
[rustsbi] Platform SMP       : 1
[rustsbi] Platform Memory    : 0x80000000..0x88000000
[rustsbi] Boot HART          : 0
[rustsbi] Device Tree Region : 0x87000000..0x87000ef2
[rustsbi] Firmware Address   : 0x80000000
[rustsbi] Supervisor Address : 0x80200000
[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)
[rustsbi] pmp02: 0x80000000..0x80200000 (---)
[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)
Hello, world!
[DEBUG] .rodata [0x80203000, 0x80205000)
[ INFO] .data [0x80205000, 0x80206000)
[ WARN] boot_stack [0x80206000, 0x80216000)
[ERROR] .bss [0x80216000, 0x80217000)
Panicked at src/main.rs:48 Shutdown machine!
```

实验成功。

## 第一章：应用程序与基本执行环境 - lab0-0 (July 08 - July 09)

在本章中，我们会打造一个能打印 `Hello, world!` 的 OS，深入理解应用程序及其执行环境。

[**Classroom** - *LearningOS / lab0-0-setup-env-run-os1-Yakkhini*](https://github.com/LearningOS/lab0-0-setup-env-run-os1-Yakkhini)

### 应用程序执行环境

一个应用程序的执行大概会通过四层路径，自顶向下：程序函数（`main.rs/main()/println!`） -> 标准库（`std, GUN Libc`） -> 内核与操作系统的指令集（`Linux kernel 5.15/x86_64`） -> 硬件（`cpu`）。

#### 目标三原组

除程序函数外，运行时库、指令集架构、操作系统类型共同构成了程序运行的平台。这三者也被叫做 **目标三元组**。如上述 `hello world` 程序，其平台就为 `x86_64` 指令集，`Linux` 操作系统，`GNU Libc` 运行时库。

我们要写操作系统，所以除指令集已定义 `riscv64gc` ，我们均无法使用其他操作系统及内置的运行时库。而 Rust 标准库 `std` 也无法使用。所以应仅依赖 Rust 无需操作系统支持的 `core` 核心库。

```rust
// os/src/main.rs

#![no_std]

fn main() {
}
```

我们移除了 `println!` 宏，因为这是一个由 `std` 提供的宏。

#### 程序是怎样被执行的

##### 编译

##### 内存

### 代码实现

#### 代码组织

我在 `zCore/` 中进行所有操作，所以 Cargo Config 文件放在 `zCore/.cargo/config` 中。

```toml
# os/.cargo/config
[build]
target = "riscv64gc-unknown-none-elf"
```

为了保证 VSCode 中 rust-analyzer 可以检测到我的工作文件夹，我也在根目录放了一个 Cargo Workspace 文件：

```toml
# zCore/Cargo.toml
[workspace]

members = [
    "./lab0-0-setup-env-run-os1-Yakkhini/os",
]
```

同时我发现需要将 `riscv64gc-unknown-none-elf` target 安装到本地：

```bash
> rustup target add riscv64gc-unknown-none-elf
```

在下一步的学习中，我发现我由于对操作系统理解不够，因而许多实验书中的概念都不了解。对于操作系统零基础的同学，我建议大家去看未精简的原书 [**rCore-Tutorial-Book 第三版**](https://rcore-os.github.io/rCore-Tutorial-Book-v3/index.html) 参考学习。

#### 移除标准库依赖

#### 汇编和链接器

## 第二章：批处理系统 - lab0-1 (July 09 - July 10)

[**Classroom** - *LearningOS / lab0-1-run-os2-Yakkhini*](https://github.com/LearningOS/lab0-1-run-os2-Yakkhini)

### CI 自动评分系统内置的 riscv 依赖出错

todo

### 原理

todo

### 代码

todo

## 第三章：多道程序与分时多任务 - lab1 (July 10 - July 11)

[**Classroom** - *LearningOS / lab1-os3-Yakkhini*](https://github.com/LearningOS/lab1-os3-Yakkhini)

### 原理

#### TaskManager：常量与变量的内存布局

### 代码

#### 使用固定长度数组存放调用次数数据

易于维护和拓展

#### 深入 TaskControlBlock

todo

## 参考

[*Open-Source-OS-Training-Camp-2022 文档*](https://learningos.github.io/rust-based-os-comp2022/index.html)

[*rCore-Tutorial-Book 第三版*](https://rcore-os.github.io/rCore-Tutorial-Book-v3/index.html)

[*SCHEDULING.md*](https://github.com/LearningOS/rust-based-os-comp2022/blob/main/scheduling.md)

[*Rust 程序设计语言 - Rust 程序设计语言 简体中文版*](https://kaisery.github.io/trpl-zh-cn/title-page.html)

[*std - Rust*](https://doc.rust-lang.org/std/index.html)

[*QEMU - ArchWiki*](https://wiki.archlinux.org/title/QEMU)