# 2022 年开源操作系统训练营

在这个训练营中，我会深入学习操作系统原理，**从零开始** 用 **Rust** 语言写一个基于 **RISC-V** 架构的 **类 Unix 内核。**

## 环境配置

### 远程仓库

需要注意的是，所有远程仓库可见性应设置为 Public 公开状态，否则 GitHub Action 中的自动评分可能无权开始，或者需付费才能使用。

### 本地

我计划在本地开发，目前使用的是 Manjaro 系统。我将所有实验会用到的文件和仓库都存放在了 `/diske/Rust/zCore/` 路径中。`/diske` 是我挂载的 Windows 系统的 E 盘。

本文档也使用软链接进来了。

```bash
> ln -s ~/Documents/YeChaNvCinema/docs/computerSci/20220706-zcore.md /diske/Rust/zCore/diary.md
```

## 学习 Rust 编程 (July 06 - July 08)

由于我之前使用 Rust 开发过一个完整的游戏项目（见 [Planting Pong](https://github.com/Yakkhini/PongPlanting)），所以系统地学习过 Rust 语言。但是我仍然想跟着训练营再过一下 Rust，因为我之前的开发比较面向业务逻辑，而操作系统的编写肯定还需要更高的要求，如错误处理、多线程并发之类的高级用法也可能会用到。

[**Classroom** - *LearningOS / learn_rust_rustlings-Yakkhini*](https://github.com/LearningOS/learn_rust_rustlings-Yakkhini)

配置 GitHub Classroom:

```bash
> make setupclassroom
```

### Rustlings 安装及使用

训练营的 Rust 习题实验是由 `rustlings` 工具驱动的。虽然 AUR 中可以安装，但是为了方便和易于管理我将它安装在了 `$HOME/.cargo/bin` 中。

```bash
> curl -L https://raw.githubusercontent.com/rust-lang/rustlings/main/install.sh | bash
```

使用：

```bash
~/.cargo/bin/rustlings watch

```

### 重点题目汇总

在学习过程中，我发现我的担心是正确的。由于我之前的开发比较侧重于业务逻辑，所以前 40 道题的内容完成速度很快，对其中的概念也比较熟悉；但是后三十道题的完成比较艰难。其中，主要耗费时间的题目类型有 **错误处理、泛型、宏、迭代器、智能指针、线程。**我在这里列举出一些重点题目，并附出解决办法中应注意的部分。

<!-- tabs:start -->

#### **Index**

* 错误处理：error6，advanced_errs1
* 泛型：generics2
* 宏：quiz4
* 迭代器：iterators4，iterators5
* 智能指针：box1
* 线程：arc1

#### **error6**

```rust
// errors6.rs

// Using catch-all error types like `Box<dyn error::Error>` isn't recommended
// for library code, where callers might want to make decisions based on the
// error content, instead of printing it out or propagating it further. Here,
// we define a custom error type to make it possible for callers to decide
// what to do next when our function returns an error.

// Make these tests pass! Execute `rustlings hint errors6` for hints :)

use std::num::ParseIntError;

// This is a custom error type that we will be using in `parse_pos_nonzero()`.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl ParsePosNonzeroError {
    // TODO: add another error conversion function here.
    fn from_creation(x: CreationError) -> ParsePosNonzeroError {
        match x {
            CreationError::Negative => ParsePosNonzeroError::Creation(CreationError::Negative),
            CreationError::Zero => ParsePosNonzeroError::Creation(CreationError::Zero),
        }
    }
}

fn parse_pos_nonzero(s: &str) -> Result<PositiveNonzeroInteger, ParsePosNonzeroError> {
    // TODO: change this to return an appropriate error instead of panicking
    // when `parse()` returns an error.
    let x = s.parse();

    match x {
        Ok(x) => PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation),
        Err(e) => {Err(ParsePosNonzeroError::ParseInt(e))},
    }
}

// Don't change anything below this line.

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        match value {
            x if x < 0 => Err(CreationError::Negative),
            x if x == 0 => Err(CreationError::Zero),
            x => Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}
```

#### **generics2**

```rust
// This powerful wrapper provides the ability to store a positive integer value.
// Rewrite it using generics so that it supports wrapping ANY type.

// Execute `rustlings hint generics2` for hints!

struct Wrapper<T> {
    value: T,
}

impl<T> Wrapper<T> {
    pub fn new(value: T) -> Self {
        Wrapper { value }
    }
}
```

#### **iterators4**

```rust
// iterators4.rs

pub fn factorial(num: u64) -> u64 {
    // Complete this function to return the factorial of num
    // Do not use:
    // - return
    // Try not to use:
    // - imperative style loops (for, while)
    // - additional variables
    // For an extra challenge, don't use:
    // - recursion
    // Execute `rustlings hint iterators4` for hints.

    (1..num + 1).product()
}
```

#### **iterators5**

```rust
// iterators5.rs
// Let's define a simple model to track Rustlings exercise progress. Progress
// will be modelled using a hash map. The name of the exercise is the key and
// the progress is the value. Two counting functions were created to count the
// number of exercises with a given progress. These counting functions use
// imperative style for loops. Recreate this counting functionality using
// iterators. Only the two iterator methods (count_iterator and
// count_collection_iterator) need to be modified.
// Execute `rustlings hint iterators5` for hints.
//
// Make the code compile and the tests pass.

use std::collections::HashMap;

#[derive(Clone, Copy, PartialEq, Eq)]
enum Progress {
    None,
    Some,
    Complete,
}

...

fn count_iterator(map: &HashMap<String, Progress>, value: Progress) -> usize {
    // map is a hashmap with String keys and Progress values.
    // map = { "variables1": Complete, "from_str": None, ... }

    map.values().filter(|val| **val == value).count()
}

...

fn count_collection_iterator(collection: &[HashMap<String, Progress>], value: Progress) -> usize {
    // collection is a slice of hashmaps.
    // collection = [{ "variables1": Complete, "from_str": None, ... },
    //     { "variables2": Complete, ... }, ... ]

    collection
        .iter()
        .map(|submap| submap.values().filter(|val| **val == value).count())
        .sum()
}

```

#### **box1**

```rust
// box1.rs
//
// At compile time, Rust needs to know how much space a type takes up. This becomes problematic
// for recursive types, where a value can have as part of itself another value of the same type.
// To get around the issue, we can use a `Box` - a smart pointer used to store data on the heap,
// which also allows us to wrap a recursive type.
//
// The recursive type we're implementing in this exercise is the `cons list` - a data structure
// frequently found in functional programming languages. Each item in a cons list contains two
// elements: the value of the current item and the next item. The last item is a value called `Nil`.
//
// Step 1: use a `Box` in the enum definition to make the code compile
// Step 2: create both empty and non-empty cons lists by replacing `unimplemented!()`
//
// Note: the tests should not be changed
//
// Execute `rustlings hint box1` for hints :)

#[derive(PartialEq, Debug)]
pub enum List {
    Cons(i32, Box<List>),
    Nil,
}

fn main() {
    println!("This is an empty cons list: {:?}", create_empty_list());
    println!(
        "This is a non-empty cons list: {:?}",
        create_non_empty_list()
    );
}

pub fn create_empty_list() -> List {
    List::Nil
}

pub fn create_non_empty_list() -> List {
    List::Cons(1, Box::new(List::Nil))
}

```

#### **arc1**

```rust
/ arc1.rs
// In this exercise, we are given a Vec of u32 called "numbers" with values ranging
// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]
// We would like to use this set of numbers within 8 different threads simultaneously.
// Each thread is going to get the sum of every eighth value, with an offset.
// The first thread (offset 0), will sum 0, 8, 16, ...
// The second thread (offset 1), will sum 1, 9, 17, ...
// The third thread (offset 2), will sum 2, 10, 18, ...
// ...
// The eighth thread (offset 7), will sum 7, 15, 23, ...

// Because we are using threads, our values need to be thread-safe.  Therefore,
// we are using Arc.  We need to make a change in each of the two TODOs.

// Make this code compile by filling in a value for `shared_numbers` where the
// first TODO comment is, and create an initial binding for `child_numbers`
// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!
// Execute `rustlings hint arc1` for hints :)

#![forbid(unused_imports)] // Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let shared_numbers = Arc::new(numbers); // TODO
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = Arc::clone(&shared_numbers); // TODO
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();
            println!("Sum of offset {} is {}", offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}

```

#### **quiz4**

```rust
#[macro_export]
macro_rules! my_macro {
    ($val:expr) => {
        "Hello ".to_owned() + $val
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_my_macro_world() {
        assert_eq!(my_macro!("world!"), "Hello world!");
    }

    #[test]
    fn test_my_macro_goodbye() {
        assert_eq!(my_macro!("goodbye!"), "Hello goodbye!");
    }
}

```

#### **advanced_errs1**

```rust
// advanced_errs1.rs

// Remember back in errors6, we had multiple mapping functions so that we
// could translate lower-level errors into our custom error type using
// `map_err()`? What if we could use the `?` operator directly instead?

// Make this code compile! Execute `rustlings hint advanced_errs1` for
// hints :)

use std::num::ParseIntError;
use std::str::FromStr;

// This is a custom error type that we will be using in the `FromStr`
// implementation.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl From<CreationError> for ParsePosNonzeroError {
    fn from(e: CreationError) -> Self {
        // TODO: complete this implementation so that the `?` operator will
        // work for `CreationError`

        ParsePosNonzeroError::Creation(e)
    }
}

// TODO: implement another instance of the `From` trait here so that the
// `?` operator will work in the other place in the `FromStr`
// implementation below.

impl From<ParseIntError> for ParsePosNonzeroError {
    fn from(e: ParseIntError) -> Self {
        ParsePosNonzeroError::ParseInt(e)
    }
}

// Don't change anything below this line.

impl FromStr for PositiveNonzeroInteger {
    type Err = ParsePosNonzeroError;
    fn from_str(s: &str) -> Result<PositiveNonzeroInteger, Self::Err> {
        let x: i64 = s.parse()?;
        Ok(PositiveNonzeroInteger::new(x)?)
    }
}

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        match value {
            x if x < 0 => Err(CreationError::Negative),
            x if x == 0 => Err(CreationError::Zero),
            x => Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

```

<!-- tabs:end -->

### 完成

每道题的具体完成情况可以在 GitHub Commit 记录中查到。

Quiz2 及之前题目：[Finish: Before quiz2(include quiz2). · LearningOS/learn_rust_rustlings-Yakkhini@e67dea3](https://github.com/LearningOS/learn_rust_rustlings-Yakkhini/commit/e67dea32e9a5b03114d544276c0e4cef82238d52)

Quiz2 之后所有题目：[Finish: All Done. · LearningOS/learn_rust_rustlings-Yakkhini@a079df7](https://github.com/LearningOS/learn_rust_rustlings-Yakkhini/commit/a079df7a058b67ee67cd9e385df90995a9a4fe38)

```bash

🎉 All exercises completed! 🎉

+----------------------------------------------------+
|          You made it to the Fe-nish line!          |
+--------------------------  ------------------------+
                          \\/
     ▒▒          ▒▒▒▒▒▒▒▒      ▒▒▒▒▒▒▒▒          ▒▒
   ▒▒▒▒  ▒▒    ▒▒        ▒▒  ▒▒        ▒▒    ▒▒  ▒▒▒▒
   ▒▒▒▒  ▒▒  ▒▒            ▒▒            ▒▒  ▒▒  ▒▒▒▒
 ░░▒▒▒▒░░▒▒  ▒▒            ▒▒            ▒▒  ▒▒░░▒▒▒▒
   ▓▓▓▓▓▓▓▓  ▓▓      ▓▓██  ▓▓  ▓▓██      ▓▓  ▓▓▓▓▓▓▓▓
     ▒▒▒▒    ▒▒      ████  ▒▒  ████      ▒▒░░  ▒▒▒▒
       ▒▒  ▒▒▒▒▒▒        ▒▒▒▒▒▒        ▒▒▒▒▒▒  ▒▒
         ▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒▒▒▓▓▒▒▓▓▒▒▒▒▒▒▒▒
           ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
             ▒▒▒▒▒▒▒▒▒▒██▒▒▒▒▒▒██▒▒▒▒▒▒▒▒▒▒
           ▒▒  ▒▒▒▒▒▒▒▒▒▒██████▒▒▒▒▒▒▒▒▒▒  ▒▒
         ▒▒    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒    ▒▒
       ▒▒    ▒▒    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒    ▒▒    ▒▒
       ▒▒  ▒▒    ▒▒                  ▒▒    ▒▒  ▒▒
           ▒▒  ▒▒                      ▒▒  ▒▒

We hope you enjoyed learning about the various aspects of Rust!
If you noticed any issues, please don't hesitate to report them to our repo.
You can also contribute your own exercises to help the greater community!

Before reporting an issue or contributing, please read our guidelines:
https://github.com/rust-lang/rustlings/blob/main/CONTRIBUTING.md

```

## 第零章：实验环境配置 - lab0-0 (July 08)

在本章中，我们会完成环境配置并成功运行 **rCore-Tutorial**。

[**Classroom** - *LearningOS / lab0-0-setup-env-run-os1-Yakkhini*](https://github.com/LearningOS/lab0-0-setup-env-run-os1-Yakkhini)

### 安装 Qemu

我计划采用本地开发。Qemu 相关软件包在 Arch 的 `extra/` 仓库中可以找到，打包质量有保证。

```bash
> yay -S qemu qemu-system-riscv qemu-user
> qemu-system-riscv64 --version; qemu-riscv64 --version;
```

**Output：**

```
QEMU emulator version 7.0.0
Copyright (c) 2003-2022 Fabrice Bellard and the QEMU Project developers
qemu-riscv64 version 7.0.0
Copyright (c) 2003-2022 Fabrice Bellard and the QEMU Project developers
```

### 试运行 rCore-Tutorial

裸机操作系统 `os1` 不需要处理用户代码，可以直接运行来检查本地环境是否正确配置。

```bash
> cd os1; LOG=DEBUG make run;
```

**Output：**

```
(rustup target list | grep "riscv64gc-unknown-none-elf (installed)") || rustup target add riscv64gc-unknown-none-elf
riscv64gc-unknown-none-elf (installed)
cargo install cargo-binutils --vers ~0.2
    Updating crates.io index
     Ignored package `cargo-binutils v0.2.0` is already installed, use --force to override
rustup component add rust-src
info: component 'rust-src' is up to date
rustup component add llvm-tools-preview
info: component 'llvm-tools-preview' for target 'x86_64-unknown-linux-gnu' is up to date
    Finished release [optimized] target(s) in 0.01s
make: rust-objcopy: No such file or directory
make: *** [Makefile:22: target/riscv64gc-unknown-none-elf/release/os.bin] Error 127
```

可以看到直接运行出现了错误 `make: rust-objcopy: No such file or directory`。根据实验说明，这个命令会安装一些本地可能没有的依赖。我在运行过程中没有收到 `root` 提权申请，根据项目的工具链，我推测是 `Cargo` 安装在 `~/.cargo/bin/` 目录中的可执行文件不在环境变量路径中。

```bash
> ls ~/.cargo/bin
```

**Output:**

```
cargo-nm       cargo-objdump   cargo-readobj  cargo-strip  rust-ld    rust-lld  rust-objcopy  rust-profdata  rust-size
cargo-objcopy  cargo-profdata  cargo-size     rust-ar      rustlings  rust-nm   rust-objdump  rust-readobj   rust-strip
```

果然，`rust-objcopy` 就在其中。肯定是程序直接使用命令 `rust-objcopy` 调用它失败了，现在的正确命令应该是 `~/.cargo/bin/rust-objcopy`。但是我不想把这个路径纳入环境变量（怕和 Pacman 打架），也不能修改 Makefile，因为有可能会影响评分程序执行。所以还是每次调用前先临时改一下 `PATH` 变量好了。

```bash
export PATH="${PATH}:${HOME}/.cargo/bin"
LOG=DEBUG make run
```

**Output:**

```
(rustup target list | grep "riscv64gc-unknown-none-elf (installed)") || rustup target add riscv64gc-unknown-none-elf
riscv64gc-unknown-none-elf (installed)
cargo install cargo-binutils --vers ~0.2
    Updating crates.io index
     Ignored package `cargo-binutils v0.2.0` is already installed, use --force to override
rustup component add rust-src
info: component 'rust-src' is up to date
rustup component add llvm-tools-preview
info: component 'llvm-tools-preview' for target 'x86_64-unknown-linux-gnu' is up to date
    Finished release [optimized] target(s) in 0.01s
[rustsbi] RustSBI version 0.2.2, adapting to RISC-V SBI v1.0.0
.______       __    __      _______.___________.  _______..______   __
|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |
|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |
|      /     |  |  |  |    \   \       |  |      \   \    |   _  < |  |
|  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |
| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|
[rustsbi] Implementation     : RustSBI-QEMU Version 0.1.1
[rustsbi] Platform Name      : riscv-virtio,qemu
[rustsbi] Platform SMP       : 1
[rustsbi] Platform Memory    : 0x80000000..0x88000000
[rustsbi] Boot HART          : 0
[rustsbi] Device Tree Region : 0x87000000..0x87000ef2
[rustsbi] Firmware Address   : 0x80000000
[rustsbi] Supervisor Address : 0x80200000
[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)
[rustsbi] pmp02: 0x80000000..0x80200000 (---)
[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)
Hello, world!
[DEBUG] .rodata [0x80203000, 0x80205000)
[ INFO] .data [0x80205000, 0x80206000)
[ WARN] boot_stack [0x80206000, 0x80216000)
[ERROR] .bss [0x80216000, 0x80217000)
Panicked at src/main.rs:48 Shutdown machine!
```

实验成功。

## 第一章：应用程序与基本执行环境 - lab0-0 (July 08 - July 09)

在本章中，我们会打造一个能打印 `Hello, world!` 的 OS，深入理解应用程序及其执行环境。

[**Classroom** - *LearningOS / lab0-0-setup-env-run-os1-Yakkhini*](https://github.com/LearningOS/lab0-0-setup-env-run-os1-Yakkhini)

### 应用程序执行环境

一个应用程序的执行大概会通过四层路径，自顶向下：程序函数（`main.rs/main()/println!`） -> 标准库（`std, GUN Libc`） -> 内核与操作系统的指令集（`Linux kernel 5.15/x86_64`） -> 硬件（`cpu`）。

#### 目标三原组

除程序函数外，运行时库、指令集架构、操作系统类型共同构成了程序运行的平台。这三者也被叫做 **目标三元组**。如上述 `hello world` 程序，其平台就为 `x86_64` 指令集，`Linux` 操作系统，`GNU Libc` 运行时库。

#### 程序是怎样被执行的

##### 内存

源代码被编译成可执行文件后，其内部的字节大概可以分为 **代码** 和 **数据** 两部分。代码会被 CPU 解析并执行，而数据部分则指示了代码中读写数据的操作应该发生在内存的哪部分空间中。

不过，由于我们知道在程序运行的过程中会出现很多不同类型、生命周期、容量、功能的数据结构，如果将它们全部放在一起的话会让空间管理难以进行。所以我们进一步地分了很多 **段** 来存放数据。不同的段依照一定规则放在内存的不同位置上，构成程序的 **内存布局。**如：

![一种典型的内存布局](img/zcore-MemoryLayout.png)

从这个布局中我们看到，存放的数据大概被分成了代码内容和数据内容两个部分。

* `.text` 部分存放编译出的汇编代码。
* `.rodata` 存放只读的全局数据，`.data` 存放可读写的全局数据。这两者共同构成 **已初始化数据段。**
* `.bss` 则存放程序未初始化的全局数据，由加载者初始化。其中的数据初始化后就会存放在已初始化数据段中。所以，一般来说，`.bss` 数据段会在程序运行过程中逐步缩小。
* `heap` **堆** 存放程序运行时动态分配的数据（如不定长可扩展的数组和向量），由低地址向高地址增长。
* `stack` **栈** 用作 **调用上下文的保存与恢复，**以及存放一些局部变量，由高地址向低地址增长。

##### 编译

编译流程大概包括三道工序，经过三个组件，它们分别是 **编译器、汇编器、链接器。** 编译器将我们 ASCLL 码的 Rust 源代码文件 `*.rs` 转为汇编语言，而汇编器再将汇编语言转为机器可读取的二进制码。

那么链接器是做什么的呢？我们在写程序的时候，定义变量、常量都使用了高级语言的语法。但是在程序运行中，程序想要使用一个数据只能去寻址访问，找到所需数据在内存中存放的地址来进行读写操作。这一步翻译工作会在汇编和机器码层面做出来。

但是这就出现了一个问题：**各个原文件是由编译器、汇编器单独编译的，那么它们就无从得知彼此所需数据的位置，更无法协调内存布局。**如果直接执行，很有可能会彼此冲突，造成严重的错误。链接器就是做这件事的：将各个源文件汇编的布局，按段拆分，再重新组合：

![链接器工作图示](img/zcore-link-sections.png)

如图所示，如果直接将 `1.O`，`2.O` 拿去运行，那 CPU 在读取 `2.O` 的 `.rodata` 位置 `0x1000` 时可能就会读到 `1.O` 的 `.text` 段。实际上，这样两个冲突的内存布局可能都无法正常开始运行，更没有读取操作了。而在组合成 `output.O` 后，内存布局不再矛盾，程序正常运行。

### 代码实现

#### 代码组织

我发现需要将 `riscv64gc-unknown-none-elf` target 安装到本地：

```bash
> rustup target add riscv64gc-unknown-none-elf
```

在下一步的学习中，我发现我由于对操作系统理解不够，因而许多实验书中的概念都不了解。对于操作系统零基础的同学，我建议大家去看未精简的原书 [**rCore-Tutorial-Book 第三版**](https://rcore-os.github.io/rCore-Tutorial-Book-v3/index.html) 参考学习。

#### 移除标准库依赖

我们要写操作系统，所以除指令集已定义 `riscv64gc` ，我们均无法使用其他操作系统及内置的运行时库。而 Rust 标准库 `std` 也无法使用。所以应仅依赖 Rust 无需操作系统支持的 `core` 核心库。

```rust
// os/src/main.rs

#![no_std]

fn main() {
}
```

我们移除了 `println!` 宏，因为这是一个由 `std` 提供的宏。

#### 汇编和链接器

正常情况下，我们在写 Rust 程序时不用管编译结果是怎样链接的，因为我们最终写的软件运行在操作系统上，而操作系统会通过虚拟地址等机制来给程序分配一个简洁透明的地址空间，供其随意分配使用。这就代表着，只要一个 Rust 项目在编译时链接器的主要工作就是组合各个文件编译的组合，让其不冲突，而不用考虑内存安排是否会与其他程序冲突，以及和内存硬件相适合。

但是，我们做操作系统开发，就不会有另一层系统来接管地址的分配和使用了。这代表着我们必须手写每个地址段在物理硬件（也就是 QEMU 给的虚拟硬件空间）内存中的布局。这需要汇编和链接器语言的支持：

<!-- tabs:start -->
##### **汇编**
```asm
# os/src/entry.asm
     .section .text.entry
     .globl _start
 _start:
     li x1, 100
```
可以看到，RISC-V 运行所需的 `_start` 汇编存放在了 `.text` 段中。之后需要把这段汇编嵌入到 Rust 代码中作为程序入口。

##### **嵌入**
```rust
// os/src/main.rs

#![no_std]
#![no_main]

mod lang_item;

use core::arch::global_asm;
global_asm!(include_str!("entry.asm"));
```

##### **链接**
再将整个程序的内存布局写出，与 QEMU 对接：
```linker
OUTPUT_ARCH(riscv)
ENTRY(_start)
BASE_ADDRESS = 0x80200000;

SECTIONS
{
    . = BASE_ADDRESS;
    skernel = .;

    stext = .;
    .text : {
        *(.text.entry)
        *(.text .text.*)
    }

    . = ALIGN(4K);
    etext = .;
    srodata = .;
    .rodata : {
        *(.rodata .rodata.*)
        *(.srodata .srodata.*)
    }

    . = ALIGN(4K);
    erodata = .;
    sdata = .;
    .data : {
        *(.data .data.*)
        *(.sdata .sdata.*)
    }

    . = ALIGN(4K);
    edata = .;
    .bss : {
        *(.bss.stack)
        sbss = .;
        *(.bss .bss.*)
        *(.sbss .sbss.*)
    }

    . = ALIGN(4K);
    ebss = .;
    ekernel = .;

    /DISCARD/ : {
        *(.eh_frame)
    }
}
```

可以看到，我们将各个地址段的存放设定为计划中 QEMU 给到的地址空间中可用的部分。

<!-- tabs:end -->

## 第二章：批处理系统 - lab0-1 (July 09 - July 10)

[**Classroom** - *LearningOS / lab0-1-run-os2-Yakkhini*](https://github.com/LearningOS/lab0-1-run-os2-Yakkhini)

### CI 自动评分系统内置的 riscv 依赖出错

todo

### 原理

todo

### 代码

todo

## 第三章：多道程序与分时多任务 - lab1 (July 10 - July 11)

[**Classroom** - *LearningOS / lab1-os3-Yakkhini*](https://github.com/LearningOS/lab1-os3-Yakkhini)

### 原理

#### TaskManager：常量与变量的内存布局

### 代码

#### 使用固定长度数组存放调用次数数据

易于维护和拓展

#### 深入 TaskControlBlock

todo

#### TaskInfo 实现的语义缺陷

## 第四章：地址空间 - lab2 (July 11 - July 16)

[**Classroom** - *LearningOS / lab2-os4-Yakkhini*](https://github.com/LearningOS/lab2-os4-Yakkhini)

> *July 11 注：今天正式去工地实习入职了，第一次上班。昨晚没睡着很困，实在没精力和 Rust 编译器搏斗了。*

### 原理

#### 地址空间

##### 使用物理空间与应用交互的缺点

##### 地址空间是一层对应用透明的伪装

#### 操作系统的动态内存

#### 分页动态内存

### 代码

#### Rust 中的堆

#### Rust 中的指针

#### Rust 中的动态内存

#### Page Number 分页系统讲解

### 重写 sys_get_time()

#### 应用与内核空间分离

#### 从物理地址拿取可变引用

### 重写 sys_task_info()

#### 代码迁移与变更

#### 修改 TaskStatus 及问题解析

### 补全 mmap(), munmap() 函数

## 第五章：进程 - lab3 (July 16 - July 17)

[**Classroom** - *LearningOS / lab3-os5-Yakkhini*](https://github.com/LearningOS/lab3-os5-Yakkhini)

### Stride 溢出和 Yield 操作的影响

## 第六章：文件系统与 I/O 重定向 - lab4 (July 17 - July 20)

[**Classroom** - *LearningOS / lab4-os6-Yakkhini*](https://github.com/LearningOS/lab4-os6-Yakkhini)

### User Shell 异常输出

## 第八章：并发 - lab5 (July 20 - July 21)

[**Classroom** - *LearningOS / lab5-os8-Yakkhini*](https://github.com/LearningOS/lab5-os8-Yakkhini)

## 参考

[*Open-Source-OS-Training-Camp-2022 文档*](https://learningos.github.io/rust-based-os-comp2022/index.html)

[*rCore-Tutorial-Book 第三版*](https://rcore-os.github.io/rCore-Tutorial-Book-v3/index.html)

[*SCHEDULING.md*](https://github.com/LearningOS/rust-based-os-comp2022/blob/main/scheduling.md)

[*Rust 程序设计语言 - Rust 程序设计语言 简体中文版*](https://kaisery.github.io/trpl-zh-cn/title-page.html)

[*std - Rust*](https://doc.rust-lang.org/std/index.html)

[*QEMU - ArchWiki*](https://wiki.archlinux.org/title/QEMU)